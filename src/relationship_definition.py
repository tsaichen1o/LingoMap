import json
import logging
from google.generativeai.generative_models import GenerativeModel
import streamlit as st
from typing import List, Dict, Any

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Prior Knowledge: A list of common properties used for linking entities.
# This guides the LLM to select from relevant, valid properties.
RELEVANT_RELATIONSHIP_PROPERTIES = [
    # FIBO properties
    "fibo-fnd-rel-rel:isSubunitOf",
    "fibo-fnd-rel-rel:hasSubunit",
    "fibo-fnd-rel-rel:isLocatedIn",
    "fibo-fnd-rel-rel:hasPart",
    "fibo-fnd-plc-adr:hasAddress",
    "fibo-be-le-fbo:hasBranch",
    # GeoSPARQL properties
    "geo:hasGeometry",
    "geo:sfWithin",
    "geo:sfContains",
    # Commons properties
    "cmns-cls:isClassifiedBy",
    "cmns-org:isAffiliatedWith",
    # Schema.org properties
    "schema:location",
    "schema:parentOrganization",
    "schema:subOrganization",
    "schema:address"
]

def define_relationships_with_llm(entities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Uses an LLM to infer and define relationships between a list of conceptual entities.
    
    Args:
        entities: A list of entity dictionaries, as generated by Stage 1.

    Returns:
        A list of dictionaries, where each represents a single relationship.
    """
    logging.info(f"Starting relationship definition for {len(entities)} entities.")

    model = GenerativeModel('gemini-2.0-flash-exp')

    # Format the list of entities for the prompt
    formatted_entity_list = "\n".join(
        f'- `{entity.get("entityId", "N/A")}`: {entity.get("entityComment", "No comment.")} (Maps to: {entity.get("mapsToClass", "N/A")})'
        for entity in entities if "error" not in entity
    )
    
    # Format the prior knowledge for the prompt
    formatted_properties_list = "\n".join(f"- `{prop}`" for prop in RELEVANT_RELATIONSHIP_PROPERTIES)

    # Design the prompt for the LLM
    prompt = f"""
# ROLE
You are a Knowledge Graph Architect and an expert in financial ontologies like FIBO, and spatial ontologies like GeoSPARQL.

# TASK
Your task is to analyze the following list of business entities and define the most logical relationships between them.
Think about how these concepts would be linked in a real-world knowledge graph. For example, a 'Branch' entity *is a subunit of* an 'Institution' entity and *has an* 'Address'.

# INPUT: LIST OF ENTITIES
{formatted_entity_list}

# RELEVANT KNOWLEDGE BASE PROPERTIES (from RAG retrieval)
You should primarily use properties from this list to define the relationships:
{formatted_properties_list}

# INSTRUCTIONS
1.  Identify and define the most important relationships between the entities from the input list.
2.  Return the result as a single, valid JSON object. The format must be a list of dictionaries.
3.  Each dictionary must represent one relationship and contain these keys:
    - `associationId`: A unique, descriptive ID for the link (e.g., "linkBranchToInstitution").
    - `sourceEntity`: The ID of the starting entity for the link.
    - `targetEntity`: The ID of the ending entity for the link.
    - `usingProperty`: The full URI of the property used to connect them (e.g., "fibo-fnd-rel-rel:isSubunitOf").
    - `justification`: A brief explanation of why this relationship is logical.
4.  Only create relationships between entities present in the input list.

# OUTPUT FORMAT (EXAMPLE)
[
  {{
    "associationId": "linkBranchToInstitution",
    "sourceEntity": "BankBranchEntity",
    "targetEntity": "BankInstitutionEntity",
    "usingProperty": "fibo-fnd-rel-rel:isSubunitOf",
    "justification": "A bank branch is a subunit of its parent financial institution."
  }},
  {{
    "associationId": "linkBranchToAddress",
    "sourceEntity": "BankBranchEntity",
    "targetEntity": "PhysicalAddressEntity",
    "usingProperty": "fibo-fnd-plc-adr:hasAddress",
    "justification": "A physical entity like a branch has a location defined by an address."
  }}
]
"""
    try:
        logging.info("Sending relationship definition prompt to Gemini...")
        response = model.generate_content(prompt)
        
        # Clean and parse the JSON response
        cleaned_json_str = response.text.strip().lstrip('```json').rstrip('```').strip()
        relationships = json.loads(cleaned_json_str)
        
        # Basic validation
        if isinstance(relationships, list):
            logging.info(f"Successfully received and parsed {len(relationships)} relationships from LLM.")
            return relationships
        else:
            logging.error("LLM returned a malformed structure for relationships (not a list).")
            return []
            
    except Exception as e:
        logging.error(f"An error occurred during relationship definition: {e}")
        st.error(f"Failed to get relationships from the LLM. Error: {e}")
        return []